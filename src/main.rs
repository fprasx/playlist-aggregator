use futures_util::StreamExt;
use rspotify::model::PlayableItem::{Episode, Track};
use rspotify::model::{PlaylistId, TrackId};
use rspotify::{prelude::*, scopes, AuthCodePkceSpotify, ClientError, Config, Credentials, OAuth};
use spotify::boxy::H;
use spotify::color::*;
use std::collections::HashSet;
use std::error::Error;
use std::fmt;
use std::io;
use std::process;
use std::time::Duration;

type GeneralResult<T> = Result<T, ProgramError>;

#[derive(Debug)]
enum ProgramError {
    RSpotify(ClientError),
    Logic(String),
}

impl fmt::Display for ProgramError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ProgramError::RSpotify(e) => write!(f, "rspotify error: {}", e),
            ProgramError::Logic(e) => write!(f, "Error: {}", e),
        }
    }
}

impl Error for ProgramError {}

#[tokio::main]
async fn main() {
    cprintln(
        r#"
      ─────────────────────────────────────┐ 
    ┌────────────────────────────────────┐ │ 
    │                                    │ │ 
    │  Welcome to playlist-aggregrator!  │ │ 
    │                                    │ │
    └────────────────────────────────────┘
    "#,
        CYAN,
    );

    println!("{YELLOW}Authorizing . . . {RESET}");

    let creds = Credentials::from_env().unwrap();

    let oauth = OAuth::from_env(scopes!(
        "playlist-read-collaborative",
        "playlist-read-private",
        "playlist-modify-public",
        "playlist-modify-private"
    ))
    .unwrap();

    let config = Config {
        token_cached: true,
        token_refreshing: true,
        ..Default::default()
    };

    let mut spotify = AuthCodePkceSpotify::with_config(creds, oauth, config);
    let url = spotify.get_authorize_url(None).unwrap();

    // TODO: need to match on this, if the token is too old it'll just panic
    spotify.prompt_for_token(&url).await.unwrap();

    println!("{YELLOW}Authorization complete!{RESET}");

    println!("{YELLOW}What would you like your aggregated playlist to be called?{RESET}");

    let mut name = String::new();

    io::stdin()
        .read_line(&mut name)
        .unwrap_or_else(|_| panic!("{RED}Failed to read name!{RESET}"));

    name = name.trim().to_owned();

    println!("{YELLOW}Retrieving tracks:{RESET}");

    let tracks = get_all_tracks(&spotify).await;

    let tracks = tracks.into_iter().collect::<Vec<_>>();

    println!("{YELLOW}Tracks retrieved!{RESET}");

    println!("{YELLOW}Creating <{GREEN}{name}{YELLOW}>. . . {RESET}");

    let new_playlist_id = match create_playlist(
        &spotify,
        name.as_str(),
        Some(false),
        Some(false),
        Some(&format!(
            "Generated by Rust on {}",
            chrono::offset::Local::now()
        )),
    )
    .await
    {
        Ok(id) => id,
        Err(e) => {
            println!("{RED}{e}{RESET}");
            process::exit(1);
        }
    };

    println!("{YELLOW}Created playlist <{GREEN}{name}{YELLOW}>{RESET}");
    // Can only add up to 100 tracks at a time
    for chunk in tracks.chunks(100) {
        match spotify
            .playlist_add_items(
                &new_playlist_id,
                chunk.iter().map(|t| t as &dyn PlayableId),
                None,
            )
            .await
        {
            Ok(_) => println!("{YELLOW}Added 100 tracks!{RESET}"),
            Err(e) => {
                println!("Adding tracks failed!");
                println!("{:#?}", e);
                match spotify.playlist_unfollow(&new_playlist_id).await {
                    Ok(_) => println!("Deleted <Test from Rust>!"),
                    Err(e) => println!("{:#?}", e),
                }
            }
        }
    }

    println!("{YELLOW}Wrote all your songs to <{GREEN}{name}{YELLOW}>{RESET}");
}

async fn get_all_tracks(spotify: &AuthCodePkceSpotify) -> HashSet<TrackId> {
    let mut tracks = HashSet::<TrackId>::new();

    // This could be lower than the actual value if there are songs in liked songs that aren't on any playlist.
    // It would be too slow to make a request for each track in `tracks`, so we just assume most tracks are in a
    // playlist. This is probably pretty safe, especially if playlists have been aggregated before.
    let playlists_dur = get_tracks_from_playlists(spotify, &mut tracks).await;
    get_tracks_from_liked_songs(spotify, &mut tracks).await;
    cprintln(H.repeat(56), RED);
    println!(
        "{:<40} {GREEN}{:04} {YELLOW}~{}{RESET}",
        "Total",
        tracks.len(),
        format_time_from_secs(playlists_dur.as_secs() as usize)
    );
    tracks
}

fn cprintln(s: impl fmt::Display, color: Color) {
    println!("{color}{s}{RESET}")
}

// Create a new playlist
//
// Returns an error if a playlist with the same name already exists
// TODO: ask if they want ot overwrite if it already exists
async fn create_playlist(
    spotify: &impl OAuthClient,
    name: &str,
    collaborative: Option<bool>,
    public: Option<bool>,
    description: Option<&str>,
) -> GeneralResult<PlaylistId> {
    let mut playlists = spotify.current_user_playlists();

    // Loop through playlists, if one with same name exists, return an error
    while let Some(Ok(p)) = playlists.next().await {
        let playlist = spotify.playlist(&p.id, None, None).await.unwrap();
        if playlist.name == name {
            return Err(ProgramError::Logic(format!(
                "Playlist <{}> already exists!",
                name
            )));
        };
    }

    // Make the playlist
    let id = &spotify.me().await.unwrap().id;
    match spotify
        .user_playlist_create(id, name, public, collaborative, description)
        .await
    {
        Ok(p) => Ok(p.id),
        Err(e) => Err(ProgramError::RSpotify(e)),
    }
}

// Get all tracks from liked songs, return their combind length
async fn get_tracks_from_liked_songs(
    spotify: &impl OAuthClient,
    found: &mut HashSet<TrackId>,
) -> Duration {
    let mut duration = Duration::from_secs(0);
    // Note: cannot include the function call in the while loop condition!!!
    // It will just return the first track every time, as it's making a new api call every loop iteration
    let mut saved_tracks = spotify.current_user_saved_tracks(None);
    while let Some(Ok(t)) = saved_tracks.next().await {
        found.insert(t.track.id.unwrap());
        duration = duration.checked_add(t.track.duration).unwrap();
    }
    duration
}

// Get all tracks from playlists
async fn get_tracks_from_playlists(
    spotify: &impl OAuthClient,
    found: &mut HashSet<TrackId>,
) -> Duration {
    let mut total_duration: Duration = Duration::from_secs(0);

    println!("{:<39}Tracks    h  m  s", "");

    // Note: cannot include the function call in the while loop condition!!!
    // It will just return the first playlist every time, as it's making a new api call every loop iteration
    let mut playlists = spotify.current_user_playlists();
    while let Some(Ok(playlist)) = playlists.next().await {
        // For each playlist, print out a nice message
        let (num_tracks, duration) = playlist_summary(spotify, &playlist.id).await;
        // TODO: Can't get padding right with brackets
        println!(
            "{CYAN}{:<40}{RESET} {GREEN}{:04}{RESET}  {YELLOW}{}{RESET}",
            playlist.name,
            num_tracks,
            format_time_from_secs(duration.as_secs() as usize)
        );

        let mut items = spotify.playlist_items(&playlist.id, None, None);

        // Paginate through the tracks
        while let Some(Ok(item)) = items.next().await {
            let t = match item.track {
                Some(it) => it,
                _ => continue,
            };
            if let Track(t) = t {
                if found.insert(t.id.unwrap()) {
                    // If the track wasn't found before, add its duration to the total
                    total_duration = total_duration.checked_add(t.duration).unwrap();
                }
            }
        }
    }
    total_duration
}

// Return the number of tracks and duration of a playlist
async fn playlist_summary(spotify: &impl BaseClient, id: &PlaylistId) -> (usize, Duration) {
    let mut total = 0;
    let mut duration: Duration = Duration::from_secs(0);

    let mut p = spotify.playlist_items(id, None, None);

    // Paginate through the items
    while let Some(Ok(item)) = p.next().await {
        total += 1;
        duration = duration
            .checked_add(match &item.track.unwrap() {
                Track(t) => t.duration,
                Episode(_) => Duration::from_secs(0),
            })
            .unwrap(); // You would need to have a very long playlist to overflow
    }
    (total, duration)
}

// Split a number of seconds into hours, minutes, and seconds
fn format_time_from_secs(secs: usize) -> String {
    let mut s = secs;
    let h = s / 3600;
    s %= 3600;
    let m = s / 60;
    s %= 60;
    format!("{h:03} {m:02} {s:02}")
}
