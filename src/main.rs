use core::fmt;
use futures_util::StreamExt;
use rspotify::model::PlayableItem::{Episode, Track};
use rspotify::model::{PlaylistId, TrackId};
use rspotify::{prelude::*, scopes, AuthCodePkceSpotify, ClientError, Config, Credentials, OAuth};
use std::collections::HashSet;
use std::error::Error;

type GeneralResult<T> = Result<T, ProgramError>;

#[derive(Debug)]
enum ProgramError {
    RSpotify(ClientError),
    Logic(String),
}

impl fmt::Display for ProgramError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ProgramError::RSpotify(e) => write!(f, "rspotify error: {}", e),
            ProgramError::Logic(e) => write!(f, "Error: {}", e),
        }
    }
}

impl Error for ProgramError {}

#[tokio::main]
async fn main() {
    let creds = Credentials::from_env().unwrap();

    let oauth = OAuth::from_env(scopes!(
        "playlist-read-collaborative",
        "playlist-read-private",
        "playlist-modify-public",
        "playlist-modify-private"
    ))
    .unwrap();

    let config = Config {
        token_cached: true,
        token_refreshing: true,
        ..Default::default()
    };

    let mut spotify = AuthCodePkceSpotify::with_config(creds, oauth, config);
    let url = spotify.get_authorize_url(None).unwrap();

    spotify.prompt_for_token(&url).await.unwrap();

    let mut tracks = HashSet::<TrackId>::new();

    let tracks_from_playlists = get_tracks_from_playlists(&spotify).await;
    tracks.reserve(tracks_from_playlists.len());
    for track in tracks_from_playlists {
        tracks.insert(track);
    }

    let tracks_from_liked = get_tracks_from_liked_songs(&spotify).await;
    tracks.reserve(tracks_from_liked.len());
    for track in tracks_from_liked {
        tracks.insert(track);
    }

    let tracks = tracks.into_iter().collect::<Vec<_>>();

    // add_tracks_from_liked_songs(&spotify).await;
    let new_playlist_id = create_playlist(
        &spotify,
        "All Songs",
        Some(false),
        Some(false),
        Some("Generated by Rust on 7 June"),
    )
    .await
    .unwrap();

    println!("Successfully created new playlists <Test from Rust>!");

    // Can only add up to 100 tracks at a time
    for chunk in tracks.chunks(100) {
        match spotify
            .playlist_add_items(
                &new_playlist_id,
                chunk.iter().map(|t| t as &dyn PlayableId),
                None,
            )
            .await
        {
            Ok(_) => println!("Successfully added 100 tracks!"),
            Err(e) => {
                println!("Adding tracks failed!");
                println!("{:#?}", e);
                match spotify.playlist_unfollow(&new_playlist_id).await {
                    Ok(_) => println!("Deleted <Test from Rust>!"),
                    Err(e) => println!("{:#?}", e),
                }
            }
        }
    }
}

async fn create_playlist(
    spotify: &impl OAuthClient,
    name: &str,
    collaborative: Option<bool>,
    public: Option<bool>,
    description: Option<&str>,
) -> GeneralResult<PlaylistId> {
    let mut playlists = spotify.current_user_playlists();
    while let Some(Ok(p)) = playlists.next().await {
        let playlist = spotify.playlist(&p.id, None, None).await.unwrap();
        if playlist.name == name {
            return Err(ProgramError::Logic(format!(
                "Playlist <{}> already exists!",
                name
            )));
        }
    }

    let id = &spotify.me().await.unwrap().id;
    match spotify
        .user_playlist_create(id, name, public, collaborative, description)
        .await
    {
        Ok(p) => Ok(p.id),
        Err(e) => Err(ProgramError::RSpotify(e)),
    }
}

async fn get_tracks_from_liked_songs(spotify: &impl OAuthClient) -> HashSet<TrackId> {
    // Note: cannot include the funciton call in the while loop condition!!!
    // It will just return the first track every time, as it's making a new api call every loop iteration
    let mut tracks = HashSet::new();
    let mut saved_tracks = spotify.current_user_saved_tracks(None);
    while let Some(Ok(t)) = saved_tracks.next().await {
        tracks.insert(t.track.id.unwrap());
    }
    tracks
}

async fn get_tracks_from_playlists(spotify: &impl OAuthClient) -> HashSet<TrackId> {
    // Note: cannot include the funciton call in the while loop condition!!!
    // It will just return the first playlist every time, as it's making a new api call every loop iteration
    let mut tracks = HashSet::new();
    let mut playlists = spotify.current_user_playlists();
    while let Some(Ok(p)) = playlists.next().await {
        let playlist = spotify.playlist(&p.id, None, None).await.unwrap();
        for item in playlist.tracks.items {
            match item.track.unwrap() {
                Track(t) => {
                    tracks.insert(t.id.unwrap());
                }
                Episode(_) => (),
            }
        }
    }
    tracks
}
