use std::fmt;
use futures_util::StreamExt;
use rspotify::model::PlayableItem::{Episode, Track};
use rspotify::model::{PlaylistId, TrackId};
use rspotify::{prelude::*, scopes, AuthCodePkceSpotify, ClientError, Config, Credentials, OAuth};
use spotify::color::*;
use std::collections::HashSet;
use std::error::Error;
use std::io;
use std::process;

fn main() {
    cprintln(r#"
        ─────────────────────────────────────┐
      ─────────────────────────────────────┐ │
    ┌────────────────────────────────────┐ │ │
    │                                    │ │ │
    │  Welcome to playlist-aggregrator!  │ │ │
    │                                    │ │
    └────────────────────────────────────┘"#, CYAN);

    box_with_outlines("Welcome to playlist-aggregator!", 4, 1, 2, 10, RED)
}

// TODO: deal with multiline
fn box_with_outlines(
    contents: &str,
    box_pad_left: usize,
    box_pad_inner_ud: usize,
    box_pad_inner_lr: usize,
    ripples: usize,
    color: Color,
) {
    let len = contents.len();
    let ul = "┌";
    let ur = "┐";
    let dl = "└";
    let dr = "┘";
    let h = "─";
    let v = "│";

    // Set the color
    print!("{color}");

    // ───── .. ─────┐
    for i in (1..ripples + 1).rev() {
        println!(
            "{}{}{ur}",
            " ".repeat(2 * i),
            h.repeat(len + box_pad_inner_lr * 2 + 2 - 1),
        );
    }

    // ┌─── .. ───┐
    println!(
        "{ul}{}{ur}",
        h.repeat(len + box_pad_inner_lr * 2),
    );

    // │ .. │
    for _ in 0..box_pad_inner_ud {
        println!(
            "{v}{}{v}",
            " ".repeat(len + box_pad_inner_lr * 2),
        );
    }

    // │ <text> │
    println!(
        "{v}{}{contents}{}{v}",
        " ".repeat(box_pad_inner_lr),
        " ".repeat(box_pad_inner_lr),
    );

    // │ .. │
    for _ in 0..box_pad_inner_ud {
        println!(
            "{v}{}{v}",
            " ".repeat(len + box_pad_inner_lr * 2),
        );
    }

    // ┌─── .. ───┐
    println!(
        "{dl}{}{dr}",
        h.repeat(len + box_pad_inner_lr * 2),
    );

    // Reset the color
    print!("{RESET}");
}

type GeneralResult<T> = Result<T, ProgramError>;

#[derive(Debug)]
enum ProgramError {
    RSpotify(ClientError),
    Logic(String),
}

impl fmt::Display for ProgramError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ProgramError::RSpotify(e) => write!(f, "rspotify error: {}", e),
            ProgramError::Logic(e) => write!(f, "Error: {}", e),
        }
    }
}

impl Error for ProgramError {}

#[tokio::main]
async fn _main() {
    println!("{YELLOW}Welcome to playlist-aggregator!{RESET}");
    println!("{YELLOW}Authorizing . . . {RESET}");

    let creds = Credentials::from_env().unwrap();

    let oauth = OAuth::from_env(scopes!(
        "playlist-read-collaborative",
        "playlist-read-private",
        "playlist-modify-public",
        "playlist-modify-private"
    ))
    .unwrap();

    let config = Config {
        token_cached: true,
        token_refreshing: true,
        ..Default::default()
    };

    let mut spotify = AuthCodePkceSpotify::with_config(creds, oauth, config);
    let url = spotify.get_authorize_url(None).unwrap();

    spotify.prompt_for_token(&url).await.unwrap();

    println!("{YELLOW}Authorization complete!{RESET}");
    println!("{YELLOW}Retrieving tracks. . . {RESET}");

    let mut tracks = HashSet::<TrackId>::new();

    let tracks_from_playlists = get_tracks_from_playlists(&spotify).await;
    tracks.reserve(tracks_from_playlists.len());
    for track in tracks_from_playlists {
        tracks.insert(track);
    }

    let tracks_from_liked = get_tracks_from_liked_songs(&spotify).await;
    tracks.reserve(tracks_from_liked.len());
    for track in tracks_from_liked {
        tracks.insert(track);
    }

    let tracks = tracks.into_iter().collect::<Vec<_>>();

    println!("{YELLOW}Tracks retrieved!{RESET}");
    println!("{YELLOW}What would you like your aggregated playlist to be called?{RESET}");

    let mut name = String::new();

    io::stdin()
        .read_line(&mut name)
        .unwrap_or_else(|_| panic!("{RED}Failed to read name!{RESET}"));

    name = name.trim().to_owned();

    // add_tracks_from_liked_songs(&spotify).await;
    let new_playlist_id = match create_playlist(
        &spotify,
        name.as_str(),
        Some(false),
        Some(false),
        Some("Generated by Rust on 7 June"),
    )
    .await
    {
        Ok(id) => id,
        Err(e) => {
            println!("{RED}{e}{RESET}");
            process::exit(1);
        }
    };

    println!("{YELLOW}Created playlist <{GREEN}{name}{YELLOW}>{RESET}");

    // Can only add up to 100 tracks at a time
    for chunk in tracks.chunks(100) {
        match spotify
            .playlist_add_items(
                &new_playlist_id,
                chunk.iter().map(|t| t as &dyn PlayableId),
                None,
            )
            .await
        {
            Ok(_) => println!("{YELLOW}Added 100 tracks!{RESET}"),
            Err(e) => {
                println!("Adding tracks failed!");
                println!("{:#?}", e);
                match spotify.playlist_unfollow(&new_playlist_id).await {
                    Ok(_) => println!("Deleted <Test from Rust>!"),
                    Err(e) => println!("{:#?}", e),
                }
            }
        }
    }
    println!("{YELLOW}Wrote all your songs to <{GREEN}{name}{YELLOW}>{RESET}");
}

fn cprintln(s: impl fmt::Display, color: Color) {
    println!("{color}{s}{RESET}")
}

async fn create_playlist(
    spotify: &impl OAuthClient,
    name: &str,
    collaborative: Option<bool>,
    public: Option<bool>,
    description: Option<&str>,
) -> GeneralResult<PlaylistId> {
    let mut playlists = spotify.current_user_playlists();
    while let Some(Ok(p)) = playlists.next().await {
        let playlist = spotify.playlist(&p.id, None, None).await.unwrap();
        if playlist.name == name {
            return Err(ProgramError::Logic(format!(
                "Playlist <{}> already exists!",
                name
            )));
        }
    }

    let id = &spotify.me().await.unwrap().id;
    match spotify
        .user_playlist_create(id, name, public, collaborative, description)
        .await
    {
        Ok(p) => Ok(p.id),
        Err(e) => Err(ProgramError::RSpotify(e)),
    }
}

async fn get_tracks_from_liked_songs(spotify: &impl OAuthClient) -> HashSet<TrackId> {
    // Note: cannot include the funciton call in the while loop condition!!!
    // It will just return the first track every time, as it's making a new api call every loop iteration
    let mut tracks = HashSet::new();
    let mut saved_tracks = spotify.current_user_saved_tracks(None);
    while let Some(Ok(t)) = saved_tracks.next().await {
        tracks.insert(t.track.id.unwrap());
    }
    tracks
}

async fn get_tracks_from_playlists(spotify: &impl OAuthClient) -> HashSet<TrackId> {
    // Note: cannot include the funciton call in the while loop condition!!!
    // It will just return the first playlist every time, as it's making a new api call every loop iteration
    let mut tracks = HashSet::new();
    let mut playlists = spotify.current_user_playlists();
    while let Some(Ok(p)) = playlists.next().await {
        let playlist = spotify.playlist(&p.id, None, None).await.unwrap();
        for item in playlist.tracks.items {
            match item.track.unwrap() {
                Track(t) => {
                    tracks.insert(t.id.unwrap());
                }
                Episode(_) => (),
            }
        }
    }
    tracks
}
